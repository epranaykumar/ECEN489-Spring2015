## Project 2 Overview
The purpose of Project 2 was to set up Four sensing stations to focus on a central area and When a MAC address is sensed in this overlapped area, take a picture using a camera next to a television. This system will then try to link a person to the mac address and possibly the image. The basic components of the system are the Micro-Controller, RF Can-tenna, and the Collector (NUC). Additionally, an external master server element was used to take all the information from the four collector stations and send/receive the various commands to initiate the camera actions. More in-depth descriptions of the four primary subsystems are given below. The WIKI used during the development of this project can be found here: [Project 2 Team 3 Wiki Page](https://github.com/CourseReps/ECEN489-Spring2015/wiki/Project-2-Team-3)

## Micro Controller (Teensy)
The Micro-Controller chosen for this project is known as Teensy board and is a small form factor Arduino type micro-controller. The purpose of the Teensy board is to power up, monitor, and transmit signals from a ping sensor. In addition to the ping sensor, we will be using a pressure plate that is controlled by the Teensy.      
**Sensors**      
The sensors serve to physically detect a target person in the area of interest. Upon sensor activation, the signal generated by the Teensy board is sent to the Collector over USB where it interfaces with a Java program. The pressure plate is a contingency that I made due to the fact that the ping sensor can be somewhat inaccurate. The combination of the electro-mechanical switch and the ping sensor will guarantee that the target person can be detected with an accuracy of nearly 100%.      
**Java Interface**      
The micro-controller is monitored by a Java interface program. This program takes the raw signal from Teensy and using if/else if/else statements compares them to a range of experimentally determined values (84-96 inches for the ping sensor and a value of 1000 for the plate) to determine if the target is indeed in the area of interest. After the raw data from the Teensy is compared, a flag is sent by the program via a JSON object over a socket to the collector's main program for action.      
**Sensor Configuration**      
To ensure accuracy, the ping sensors will be positioned in a cross formation with the ping sensors focused on the intersection. The center of the cross will be approximately 7-7.25 feet or 84-87 inches away from the ping sensors. The pressure plate will lie at the center of the cross to ensure that the area is covered if the ping sensors fail to detect.As to the Sensor module. 
* With Micro Controller module. The collector receives the commands from The sensor, for our group, there are two sensors is using. One is 
* With RF Can-tenna module. 


## RF Can-tenna

The goal for the RF antenna team is to build a directional antenna using cantenna to pin point the location of the mac address. To achieve pin pointing, Attenuators are used to reduce the sensing distance in order to pick up less signal. However, we are still able to pick signal inconsistently. Next experiment was to attach a matching load wifi card so no signal can be picked up. However, after hacking open the wifi card, we discover a second antenna that was picking up signal. Thus, it was grinded off. After running several experiment, we are still able to pick up signal. This is due to RF leakage. Unfortunately, this factor limited our implementation. We switched gear and implemented the project using RSSI reading. The idea is to pick up mac address and make sure that the 4 cantennas are getting the same value so that the server can confirm that user is exact same distance across the 4 cantennas. A difficulty we faced was that the distance of the user does not always correlated with the RSSI reading. Our decision was to limit the reading within certain range and match all mac addresses within that range to the user.


## Server-Collector
This is a multi-threaded server-client program that controls the micro controller, an android device, NUC and the Main Server for further reaction. 
* With Facial recognition module, after connecting to it, collector will send a command "TakePicture" to openCV when it is told by the server. When Facial Recognition part done with its task, it will send back to the collector a picture, named as a specific format, and as well as the time stamp. After receiving all of these, the collector will send these as a Json object to the server and waiting it to give the command back to the facial recognition module. 
* With Micro Controller module. The collector receives the commands from The sensor, for our group, there are two sensors we are using in the project. One is ping sensor and the other is pressure plate. The commands will be sent to the collector in Json object and the collector will send them to the server directly. 



## Facial Recognition
Facial Recognition on PC consists of mainly 3 modules.
-	[Open-CV module ](https://github.com/CourseReps/ECEN489-Spring2015/blob/master/Students/nranudeep1990/Project2/main.cpp)
-	[Java Client module](https://github.com/CourseReps/ECEN489-Spring2015/tree/master/Students/nranudeep1990/Project2/FaceRecClient)
-	[FTP Transfer module](https://github.com/CourseReps/ECEN489-Spring2015/tree/master/Students/nranudeep1990/Project2/Project2Server)      

**Open-CV:**      
This module is implemented in C++ using the basic Open-CV functionalities. The Video cam will be initialized to capture the frames. The captured frames are converted to gray scale before being passed through face recognition module where they were classified against the Open-CV trained data. In the Face recognition part of open-cv module the Haarcascades method gives us the boxes of detected faces, the generated boxes are cropped out of the image and are stored in the desired folder with .png format.       
**Java Client module:**      
This module creates a client socket by connecting to the server socket and immediately after the connection it sends a JSON command connect to the server with its device name. Then it listens for the command from the server to take a picture. It receives a timestamp and it passes the timestamp as a command line argument to the .exe file we are calling from the Java. A delay of 15 seconds is made to facilitate the execution of open-cv and then the directory is checked for the existing files. If number of files is just one, the FTP transfer is initiated to the server and after that filename command is sent to the server with the filename.png. If the directory is not having any files or more than one file, the command filename is sent with NULL value.      
**FTP Transfer module:**        
This module is initiated from the Java Client. It makes FTP connection with the server on specified port and authenticates with the provided username and password. It then initiates file transfer over FTP and completes the transfer with a message.


## Conclusion
Overall the design works as intended, our only issues are with the can-tenna and the ping sensor. The problem with can-tenna is that it is not as directional as we originally thought and picks up numerous MAC’s from all around it, however the MAC’s are more easily picked up from the direction that the can is pointed. The ping sensor also presented a problem when used with the other four, the signals from the other sensors seem to give erroneous data to the receptors on the sensor and will give a ping when no one is in range. The project concept can easily be adapted to security type scenarios where facial recognition and device information need to be paired up to identify a person.